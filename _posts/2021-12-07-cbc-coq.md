---
layout: post
title: Understanding the Code Behind Formalizing of CBC Casper in Coq (Safety Properties)
subtitle: Computer Science
tags: [computer science, blockchain, consensus protocol, CBC Casper, formalization, Coq]
comments: true
---

This is a joint work from the Formal Verification in Blockchain reading group, which consists of [BarnabÃ© Monnot](https://barnabemonnot.com/), [Zhangsheng Lai](https://zunction.github.io/) and myself.    

In this post, we will be understanding and covering the important definitions and results regarding the safety properties (more on this later) from the [Coq](https://coq.inria.fr/) code presented in the paper, [Formalizing Correct-by-Construction Casper in Coq](https://www.researchgate.net/publication/343704844_Formalizing_Correct-by-Construction_Casper_in_Coq), by authors from [Runtime Verification Inc](https://runtimeverification.com/).
The Coq code can be found in [here](https://runtimeverification.github.io/casper-cbc-proof-docs/docs/latest/alectryon/toc.html). 
We will also be referencing from the paper, [Introducing the "Minimal CBC Casper" Family of Consensus Protocols](https://github.com/cbc-casper/cbc-casper-paper/blob/master/cbc-casper-paper-draft.pdf), by authors from [Ethereum Research](https://ethresear.ch/) as the code covers the formalized version of the definitions and results in the paper as well.
The code presented in this post is mostly from `Protocol.v`, unless otherwise stated, as most of the definitions and results regarding the safety properties of the CBC Casper protocol are covered in this file.
We will be mapping from the formalized definitions and results found in `Protocol.v`, unless otherwise stated, to the corresponding definitions and results in either [Formalizing Correct-by-Construction Casper in Coq](https://www.researchgate.net/publication/343704844_Formalizing_Correct-by-Construction_Casper_in_Coq) or [Introducing the "Minimal CBC Casper" Family of Consensus Protocols](https://github.com/cbc-casper/cbc-casper-paper/blob/master/cbc-casper-paper-draft.pdf), or vice versa.
We will provide necessary details for each of the mappings to provide a better understanding for the readers but will not be covering most of the proofs presented.
Interested readers can either run through the Alectryon proof movies in [here](https://runtimeverification.github.io/casper-cbc-proof-docs/docs/latest/alectryon/toc.html) or read the [post](https://zunction.github.io/blog/2021/safety-proofs/) by Zhangsheng Lai, where he covers the formalized proofs of the 5 main theorems from [Introducing the "Minimal CBC Casper" Family of Consensus Protocols](https://github.com/cbc-casper/cbc-casper-paper/blob/master/cbc-casper-paper-draft.pdf).

---

### Correct-by-Construction (CBC) Casper

**Consensus protocols** can be thought of as "rules" used by nodes in a distributed network to make consistent decisions, i.e., come to consensus, from possibly inconsistent alternative decisions from different nodes. We define decisions as **consensus values**. For example, in a binary consensus protocol, where the consensus values are 0 or 1, the value 1 is said to be inconsistent with 0 and consistent with 1. In a blockchain consensus protocol, a consensus value on one block is considered as inconsistent with another when they are not in the same blockchain, and consistent when they are in the same chain. Typically, consensus protocols are to ensure several properties to hold within a blockchain, e.g., safety, liveness and non-triviality, which we will elaborate more later.

**Correct-by-Construction (CBC) Casper** is a partial specification for a family of consensus protocols and is formally defined as a type class, using the syntax `Class`, in the Coq proof assistant as shown below:

```coq
Class CBCProtocolEq :=
   {
      (** Consensus values equipped with reflexive transitive comparison **)
      consensus_values : Type;
      about_consensus_values : StrictlyComparable consensus_values;
      (** Validators equipped with reflexive transitive comparison **)
      validators : Type;
      about_validators : StrictlyComparable validators;
      (** Weights are positive reals **)
      weight : validators -> {r | (r > 0)%R};
      (** Threshold is a non-negative real **)
      t : {r | (r >= 0)%R};
      suff_val : exists vs, NoDup vs /\ ((fold_right (fun v r => (proj1_sig (weight v) + r)%R) 0%R) vs > (proj1_sig t))%R;
      (** States with equality and union **)
      state : Type;
      about_state : StrictlyComparable state;
      state0 : state;
      state_eq : state -> state -> Prop;
      state_union : state -> state -> state;
      state_union_comm : forall s1 s2, state_eq (state_union s1 s2) (state_union s2 s1);
      (** Reachability relation **)
      reach : state -> state -> Prop;
      reach_refl : forall s, reach s s;
      reach_trans : forall s1 s2 s3, reach s1 s2 -> reach s2 s3 -> reach s1 s3;
      reach_union : forall s1 s2, reach s1 (state_union s1 s2);
      reach_morphism : forall s1 s2 s3, reach s1 s2 -> state_eq s2 s3 -> reach s1 s3;
      (** Total estimator **)
      E : state -> consensus_values -> Prop;
      estimator_total : forall s, exists c, E s c;
      (** Protocol state definition as predicate **)
      prot_state : state -> Prop;
      about_state0 : prot_state state0;
      (** Equivocation weights from states **)
      equivocation_weight : state -> R;
      equivocation_weight_compat : forall s1 s2, (equivocation_weight s1 <= equivocation_weight (state_union s2 s1))%R;
      about_prot_state : forall s1 s2, prot_state s1 -> prot_state s2 ->
                                  (equivocation_weight (state_union s1 s2) <= proj1_sig t)%R -> prot_state (state_union s1 s2);
   }.
```    
    
> **Remark:** Type classes in Coq works similarly to the record types in most programming languages. One of the main differences is that in most programming languages' record types, they are used to store multiple *data types*, but for Coq's type classes, they can store *properties* and *functions* as well. This is because Coq is built through dependent type theory and is a functional programming language where *propositions* are types as well.

We will slowly break down the type class, `CBCProtocolEq`, above and understand what data and properties are required for CBC Casper protocol. CBC Casper is instantiated with 5 framework parameters to define concrete protocols:

1. **Validators** or **participating nodes**: A non-empty set, $\mathcal{V}$
    ```coq
   validators : Type;
   (** they abstract the idea of validators to any type, instead of defining a fixed set of names **)
   about_validators : StrictlyComparable validators;
   (** about_validators tells us that you can compare validators and this comparison is reflexive and transitive **)
   ```
   
    
2. **Validator weights**: A function, $\mathcal{W}: \mathcal{V} \rightarrow \mathbb{R}\_+$, that assigns a weight to each validator
   ```coq
   weight : validators -> {r | (r > 0)%R};
   (** this is how you can define function in Coq, i.e., for all validators, there exists a real number, r, that is greater than 0 **)
   ```
   
    
3. **Byzantine-fault-tolerance threshold**: A non-negative real number, $t$, strictly smaller than the total validator weights 





